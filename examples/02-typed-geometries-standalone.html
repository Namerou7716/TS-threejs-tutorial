<!DOCTYPE html>
<html lang="en">
	<head>
		<title>Three.js TypeScript Tutorial - 02 Typed Geometries</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<style>
			body {
				margin: 0;
				background-color: #000814;
				color: #fff;
				font-family: Consolas, 'Courier New', monospace;
				font-size: 12px;
				line-height: 1.4;
				overscroll-behavior: none;
			}

			#info {
				position: absolute;
				top: 0;
				width: 100%;
				padding: 15px;
				box-sizing: border-box;
				text-align: center;
				z-index: 1;
				pointer-events: none;
				background: linear-gradient(to bottom, rgba(0,0,0,0.8), transparent);
			}

			#controls {
				position: absolute;
				top: 100px;
				left: 10px;
				background: rgba(0, 20, 40, 0.9);
				padding: 20px;
				border-radius: 8px;
				border: 1px solid #00ffff;
				pointer-events: auto;
				min-width: 280px;
				max-height: 70vh;
				overflow-y: auto;
			}

			.control-section {
				margin-bottom: 15px;
				padding-bottom: 10px;
				border-bottom: 1px solid #333;
			}

			.control-section h3 {
				margin: 0 0 10px 0;
				color: #00ffff;
				font-size: 14px;
			}

			.control-row {
				display: flex;
				align-items: center;
				margin: 8px 0;
				gap: 10px;
			}

			.control-row label {
				min-width: 80px;
				color: #ccc;
				font-size: 11px;
			}

			button {
				background: linear-gradient(to bottom, #0066cc, #004499);
				border: 1px solid #00ffff;
				color: #fff;
				padding: 6px 12px;
				border-radius: 4px;
				cursor: pointer;
				font-family: inherit;
				font-size: 11px;
				transition: all 0.2s;
			}

			button:hover {
				background: linear-gradient(to bottom, #0088ff, #0066cc);
				box-shadow: 0 0 10px rgba(0, 255, 255, 0.3);
			}

			select, input[type="color"] {
				background: #222;
				border: 1px solid #555;
				color: #fff;
				padding: 4px;
				border-radius: 3px;
				font-family: inherit;
				font-size: 11px;
			}

			input[type="color"] {
				width: 40px;
				height: 25px;
				padding: 0;
				cursor: pointer;
			}

			.tutorial-title {
				font-size: 18px;
				font-weight: bold;
				margin-bottom: 5px;
				color: #00ffff;
			}

			.tutorial-description {
				font-size: 13px;
				opacity: 0.9;
				color: #fff;
			}

			.type-info {
				background: rgba(0, 255, 255, 0.1);
				padding: 10px;
				margin: 10px 0;
				border-radius: 4px;
				font-size: 11px;
				border-left: 3px solid #00ffff;
				text-align: left;
			}

			.stats {
				position: absolute;
				bottom: 10px;
				left: 10px;
				background: rgba(0, 0, 0, 0.8);
				padding: 10px;
				border-radius: 4px;
				font-size: 11px;
				color: #00ff00;
				font-family: 'Courier New', monospace;
			}

			#objectList {
				max-height: 150px;
				overflow-y: auto;
				background: #111;
				border: 1px solid #333;
				border-radius: 4px;
				padding: 5px;
			}

			.object-item {
				padding: 5px;
				margin: 2px 0;
				background: #222;
				border-radius: 3px;
				cursor: pointer;
				transition: background 0.2s;
				font-size: 11px;
			}

			.object-item:hover {
				background: #333;
			}

			.object-item.selected {
				background: #004400;
				border: 1px solid #00ff00;
			}
		</style>
	</head>
	<body>
		<div id="info">
			<div class="tutorial-title">Three.js TypeScript Tutorial - 02 Typed Geometries</div>
			<div class="tutorial-description">ÂûãÂÆâÂÖ®„Å™„Ç∏„Ç™„É°„Éà„É™„Éª„Éû„ÉÜ„É™„Ç¢„É´„Éï„Ç°„ÇØ„Éà„É™„Éº„ÅÆÂÆüË£Ö</div>
			<div class="type-info">
				<strong>TypeScript Features:</strong> Union Types, Factory Pattern, Type Guards
				<br><strong>Design Patterns:</strong> Factory Method, Type-Safe Object Creation
			</div>
		</div>

		<div id="controls">
			<div class="control-section">
				<h3>üèóÔ∏è Object Creation</h3>
				<div class="control-row">
					<label>Geometry:</label>
					<select id="geometryType">
						<option value="box">Box</option>
						<option value="sphere">Sphere</option>
						<option value="cone">Cone</option>
						<option value="cylinder">Cylinder</option>
						<option value="torus">Torus</option>
						<option value="dodecahedron">Dodecahedron</option>
					</select>
				</div>
				<div class="control-row">
					<label>Material:</label>
					<select id="materialType">
						<option value="basic">Basic</option>
						<option value="lambert">Lambert</option>
						<option value="phong">Phong</option>
						<option value="standard">Standard</option>
						<option value="normal">Normal</option>
					</select>
				</div>
				<div class="control-row">
					<label>Color:</label>
					<input type="color" id="objectColor" value="#00ff88">
					<button id="createObject">Create Object</button>
				</div>
				<button id="clearAll">Clear All</button>
			</div>

			<div class="control-section">
				<h3>üì¶ Objects (<span id="objectCount">0</span>)</h3>
				<div id="objectList">
					<div style="text-align: center; color: #666; padding: 20px;">
						No objects created yet
					</div>
				</div>
				<button id="removeSelected">Remove Selected</button>
			</div>
		</div>

		<div class="stats" id="stats">
			Objects: 0 | Triangles: 0 | Click objects to select
		</div>

		<!-- Three.js CDN -->
		<script type="importmap">
			{
				"imports": {
					"three": "https://unpkg.com/three@0.178.0/build/three.module.js"
				}
			}
		</script>

		<script type="module">
			import * as THREE from 'three';

			/**
			 * ÂûãÂÆâÂÖ®„Å™„Ç∏„Ç™„É°„Éà„É™„Éï„Ç°„ÇØ„Éà„É™„Éº (TypeScriptÈ¢®„ÅÆÂÆüË£Ö)
			 */
			class TypedGeometryFactory {
				
				/**
				 * „Ç∏„Ç™„É°„Éà„É™„Çí‰ΩúÊàê
				 */
				static createGeometry(type, config = {}) {
					switch (type) {
						case 'box':
							return new THREE.BoxGeometry(
								config.width ?? 1,
								config.height ?? 1,
								config.depth ?? 1
							);
						
						case 'sphere':
							return new THREE.SphereGeometry(
								config.radius ?? 1,
								config.widthSegments ?? 32,
								config.heightSegments ?? 16
							);
						
						case 'cone':
							return new THREE.ConeGeometry(
								config.radius ?? 1,
								config.height ?? 1,
								config.radialSegments ?? 8
							);
						
						case 'cylinder':
							return new THREE.CylinderGeometry(
								config.radius ?? 1,
								config.radius ?? 1,
								config.height ?? 1,
								config.radialSegments ?? 8
							);
						
						case 'torus':
							return new THREE.TorusGeometry(
								config.radius ?? 1,
								config.tube ?? 0.4,
								config.radialSegments ?? 8,
								config.tubularSegments ?? 6
							);
						
						case 'dodecahedron':
							return new THREE.DodecahedronGeometry(
								config.radius ?? 1,
								config.detail ?? 0
							);
						
						default:
							throw new Error(`Unsupported geometry type: ${type}`);
					}
				}

				/**
				 * „Éû„ÉÜ„É™„Ç¢„É´„Çí‰ΩúÊàê
				 */
				static createMaterial(type, config = {}) {
					const baseConfig = {
						color: config.color ?? 0xffffff,
						transparent: config.transparent ?? false,
						opacity: config.opacity ?? 1
					};
					
					switch (type) {
						case 'basic':
							return new THREE.MeshBasicMaterial(baseConfig);
						
						case 'lambert':
							return new THREE.MeshLambertMaterial({
								...baseConfig,
								emissive: config.emissive ?? 0x000000
							});
						
						case 'phong':
							return new THREE.MeshPhongMaterial({
								...baseConfig,
								emissive: config.emissive ?? 0x000000,
								specular: config.specular ?? 0x111111,
								shininess: config.shininess ?? 30
							});
						
						case 'standard':
							return new THREE.MeshStandardMaterial({
								...baseConfig,
								roughness: config.roughness ?? 1,
								metalness: config.metalness ?? 0
							});
						
						case 'normal':
							return new THREE.MeshNormalMaterial({
								transparent: baseConfig.transparent,
								opacity: baseConfig.opacity
							});
						
						default:
							throw new Error(`Unsupported material type: ${type}`);
					}
				}
			}

			/**
			 * ÂûãÂÆâÂÖ®„Å™„Ç™„Éñ„Ç∏„Çß„ÇØ„Éà„Éï„Ç°„ÇØ„Éà„É™„Éº
			 */
			class TypedObjectFactory {
				
				/**
				 * „É°„ÉÉ„Ç∑„É•„Ç™„Éñ„Ç∏„Çß„ÇØ„Éà„Çí‰ΩúÊàê
				 */
				static createMesh(config) {
					// „Ç∏„Ç™„É°„Éà„É™„ÅÆ‰ΩúÊàê
					const geometry = TypedGeometryFactory.createGeometry(
						config.geometry.type,
						config.geometry.config
					);
					
					// „Éû„ÉÜ„É™„Ç¢„É´„ÅÆ‰ΩúÊàê
					const material = TypedGeometryFactory.createMaterial(
						config.material.type,
						config.material.config
					);
					
					// „É°„ÉÉ„Ç∑„É•„ÅÆ‰ΩúÊàê
					const mesh = new THREE.Mesh(geometry, material);
					
					// ÂêçÂâç„ÅÆË®≠ÂÆö
					if (config.name) {
						mesh.name = config.name;
					}
					
					// Â§âÊèõ„ÅÆÈÅ©Áî®
					if (config.transform) {
						this.applyTransform(mesh, config.transform);
					}
					
					return mesh;
				}
				
				/**
				 * Â§âÊèõ„ÅÆÈÅ©Áî®
				 */
				static applyTransform(object, transform) {
					if (!transform) return;
					
					// ‰ΩçÁΩÆ„ÅÆË®≠ÂÆö
					if (transform.position) {
						if (transform.position.x !== undefined) object.position.x = transform.position.x;
						if (transform.position.y !== undefined) object.position.y = transform.position.y;
						if (transform.position.z !== undefined) object.position.z = transform.position.z;
					}
					
					// ÂõûËª¢„ÅÆË®≠ÂÆö
					if (transform.rotation) {
						if (transform.rotation.x !== undefined) object.rotation.x = transform.rotation.x;
						if (transform.rotation.y !== undefined) object.rotation.y = transform.rotation.y;
						if (transform.rotation.z !== undefined) object.rotation.z = transform.rotation.z;
					}
					
					// „Çπ„Ç±„Éº„É´„ÅÆË®≠ÂÆö
					if (transform.scale) {
						if (transform.scale.x !== undefined) object.scale.x = transform.scale.x;
						if (transform.scale.y !== undefined) object.scale.y = transform.scale.y;
						if (transform.scale.z !== undefined) object.scale.z = transform.scale.z;
					}
				}
			}

			/**
			 * „Ç∏„Ç™„É°„Éà„É™„Ç∑„Éß„Éº„Ç±„Éº„Çπ„ÇØ„É©„Çπ
			 */
			class TypedGeometryShowcase {
				constructor() {
					this.objects = [];
					this.selectedObject = null;
					this.animationId = null;
					this.clock = new THREE.Clock();
					
					this.setupScene();
					this.setupLighting();
					this.setupControls();
					this.start();
				}

				setupScene() {
					// „Ç´„É°„É©
					this.camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
					this.camera.position.set(5, 5, 5);
					this.camera.lookAt(0, 0, 0);

					// „Ç∑„Éº„É≥
					this.scene = new THREE.Scene();
					this.scene.background = new THREE.Color(0x000814);

					// „É¨„É≥„ÉÄ„É©„Éº
					this.renderer = new THREE.WebGLRenderer({ antialias: true });
					this.renderer.setPixelRatio(window.devicePixelRatio);
					this.renderer.setSize(window.innerWidth, window.innerHeight);
					this.renderer.shadowMap.enabled = true;
					document.body.appendChild(this.renderer.domElement);

					// „É™„Çµ„Ç§„Ç∫„Ç§„Éô„É≥„Éà
					window.addEventListener('resize', this.onWindowResize.bind(this));
				}

				setupLighting() {
					// Áí∞Â¢ÉÂÖâ
					const ambientLight = new THREE.AmbientLight(0x404040, 0.4);
					this.scene.add(ambientLight);

					// ÊåáÂêëÊÄß„É©„Ç§„Éà
					const directionalLight = new THREE.DirectionalLight(0xffffff, 1);
					directionalLight.position.set(10, 10, 5);
					this.scene.add(directionalLight);

					// „Éù„Ç§„É≥„Éà„É©„Ç§„Éà
					const pointLight = new THREE.PointLight(0x00ffff, 0.5, 50);
					pointLight.position.set(-5, 5, -5);
					this.scene.add(pointLight);
				}

				setupControls() {
					const createBtn = document.getElementById('createObject');
					const clearBtn = document.getElementById('clearAll');
					const removeBtn = document.getElementById('removeSelected');

					createBtn.addEventListener('click', () => this.createObject());
					clearBtn.addEventListener('click', () => this.clearAll());
					removeBtn.addEventListener('click', () => this.removeSelected());
				}

				createObject() {
					const geometryType = document.getElementById('geometryType').value;
					const materialType = document.getElementById('materialType').value;
					const color = document.getElementById('objectColor').value;

					// ÂûãÂÆâÂÖ®„Å™„Ç™„Éñ„Ç∏„Çß„ÇØ„Éà‰ΩúÊàê
					const objectConfig = {
						geometry: { 
							type: geometryType, 
							config: this.getRandomGeometryConfig(geometryType) 
						},
						material: { 
							type: materialType, 
							config: { 
								color,
								roughness: materialType === 'standard' ? Math.random() * 0.5 + 0.2 : undefined,
								metalness: materialType === 'standard' ? Math.random() * 0.8 : undefined
							} 
						},
						transform: {
							position: {
								x: (Math.random() - 0.5) * 10,
								y: (Math.random() - 0.5) * 8,
								z: (Math.random() - 0.5) * 10
							}
						},
						name: `${geometryType}_${materialType}_${Date.now()}`
					};

					const mesh = TypedObjectFactory.createMesh(objectConfig);
					mesh.castShadow = true;
					mesh.receiveShadow = true;
					
					this.scene.add(mesh);
					this.objects.push(mesh);
					this.updateObjectList();
				}

				getRandomGeometryConfig(type) {
					const configs = {
						box: { width: 0.5 + Math.random() * 2, height: 0.5 + Math.random() * 2, depth: 0.5 + Math.random() * 2 },
						sphere: { radius: 0.3 + Math.random() * 1.5, widthSegments: 16 + Math.floor(Math.random() * 16) },
						cone: { radius: 0.3 + Math.random() * 1.2, height: 0.5 + Math.random() * 2.5 },
						cylinder: { radius: 0.3 + Math.random() * 1.2, height: 0.5 + Math.random() * 2.5 },
						torus: { radius: 0.5 + Math.random() * 1, tube: 0.1 + Math.random() * 0.4 },
						dodecahedron: { radius: 0.3 + Math.random() * 1.5 }
					};
					return configs[type] || {};
				}

				updateObjectList() {
					const container = document.getElementById('objectList');
					const countElement = document.getElementById('objectCount');
					
					countElement.textContent = this.objects.length.toString();
					
					if (this.objects.length === 0) {
						container.innerHTML = '<div style="text-align: center; color: #666; padding: 20px;">No objects created yet</div>';
						return;
					}

					container.innerHTML = '';
					
					this.objects.forEach((obj, index) => {
						const item = document.createElement('div');
						item.className = 'object-item';
						item.textContent = `${index + 1}. ${obj.name}`;
						item.addEventListener('click', () => this.selectObject(obj, item));
						container.appendChild(item);
					});
				}

				selectObject(obj, element) {
					// Ââç„ÅÆÈÅ∏Êäû„ÇíËß£Èô§
					document.querySelectorAll('.object-item').forEach(el => el.classList.remove('selected'));
					
					// Êñ∞„Åó„ÅÑÈÅ∏Êäû
					this.selectedObject = obj;
					element.classList.add('selected');
				}

				removeSelected() {
					if (!this.selectedObject) return;

					this.scene.remove(this.selectedObject);
					this.selectedObject.geometry.dispose();
					this.selectedObject.material.dispose();
					
					const index = this.objects.indexOf(this.selectedObject);
					if (index > -1) {
						this.objects.splice(index, 1);
					}
					
					this.selectedObject = null;
					this.updateObjectList();
				}

				clearAll() {
					this.objects.forEach(obj => {
						this.scene.remove(obj);
						obj.geometry.dispose();
						obj.material.dispose();
					});
					
					this.objects = [];
					this.selectedObject = null;
					this.updateObjectList();
				}

				onWindowResize() {
					this.camera.aspect = window.innerWidth / window.innerHeight;
					this.camera.updateProjectionMatrix();
					this.renderer.setSize(window.innerWidth, window.innerHeight);
				}

				animate() {
					this.animationId = requestAnimationFrame(this.animate.bind(this));
					
					const time = this.clock.getElapsedTime();
					
					// „Ç™„Éñ„Ç∏„Çß„ÇØ„Éà„ÅÆ„Ç¢„Éã„É°„Éº„Ç∑„Éß„É≥
					this.objects.forEach((obj, index) => {
						obj.rotation.x = time * 0.5 + index * 0.1;
						obj.rotation.y = time * 0.3 + index * 0.15;
					});

					// Áµ±Ë®àÊÉÖÂ†±„ÅÆÊõ¥Êñ∞
					this.updateStats();
					
					this.renderer.render(this.scene, this.camera);
				}

				updateStats() {
					const triangles = this.objects.reduce((sum, obj) => {
						const geometry = obj.geometry;
						return sum + (geometry.attributes.position?.count || 0) / 3;
					}, 0);

					const stats = document.getElementById('stats');
					stats.textContent = `Objects: ${this.objects.length} | Triangles: ${Math.floor(triangles)} | Click objects to select`;
				}

				start() {
					this.animate();
				}

				dispose() {
					if (this.animationId) {
						cancelAnimationFrame(this.animationId);
					}
					this.clearAll();
					this.renderer.dispose();
				}
			}

			// „Ç¢„Éó„É™„Ç±„Éº„Ç∑„Éß„É≥ÈñãÂßã
			const app = new TypedGeometryShowcase();

			// TypeScriptÈñãÁô∫ËÄÖÂêë„Åë„Ç≥„É≥„ÇΩ„Éº„É´ÊÉÖÂ†±
			console.group('üîß TypeScript Three.js Development');
			console.log('üìù Type Safety:', 'Factory pattern with type checking');
			console.log('üè≠ Factory Pattern:', 'Type-safe object creation');
			console.log('üîó Design:', 'Geometry and Material abstraction');
			console.log('‚ö° Features:', 'Interactive object management');
			console.groupEnd();

			// „ÇØ„É™„Éº„É≥„Ç¢„ÉÉ„Éó
			window.addEventListener('beforeunload', () => {
				app.dispose();
			});
		</script>

	</body>
</html>