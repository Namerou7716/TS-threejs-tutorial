<!DOCTYPE html>
<html lang="en">
	<head>
		<title>Three.js TypeScript Tutorial - 02 Typed Geometries</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<style>
			body {
				margin: 0;
				background-color: #000;
				color: #fff;
				font-family: Consolas, 'Courier New', monospace;
				font-size: 12px;
				line-height: 1.4;
				overscroll-behavior: none;
			}

			#info {
				position: absolute;
				top: 0;
				width: 100%;
				padding: 15px;
				box-sizing: border-box;
				text-align: center;
				z-index: 1;
				pointer-events: none;
				background: linear-gradient(to bottom, rgba(0,0,0,0.8), transparent);
			}

			#controls {
				position: absolute;
				top: 100px;
				left: 10px;
				background: rgba(0, 20, 40, 0.9);
				padding: 20px;
				border-radius: 8px;
				border: 1px solid #00ffff;
				pointer-events: auto;
				min-width: 280px;
				max-height: 70vh;
				overflow-y: auto;
			}

			.control-section {
				margin-bottom: 15px;
				padding-bottom: 10px;
				border-bottom: 1px solid #333;
			}

			.control-section:last-child {
				border-bottom: none;
			}

			.control-section h3 {
				margin: 0 0 10px 0;
				color: #00ffff;
				font-size: 14px;
			}

			.control-row {
				display: flex;
				align-items: center;
				margin: 8px 0;
				gap: 10px;
			}

			.control-row label {
				min-width: 80px;
				color: #ccc;
				font-size: 11px;
			}

			button {
				background: linear-gradient(to bottom, #0066cc, #004499);
				border: 1px solid #00ffff;
				color: #fff;
				padding: 6px 12px;
				border-radius: 4px;
				cursor: pointer;
				font-family: inherit;
				font-size: 11px;
				transition: all 0.2s;
			}

			button:hover {
				background: linear-gradient(to bottom, #0088ff, #0066cc);
				box-shadow: 0 0 10px rgba(0, 255, 255, 0.3);
			}

			button.active {
				background: linear-gradient(to bottom, #00aa00, #008800);
				border-color: #00ff00;
			}

			select, input[type="range"], input[type="color"] {
				background: #222;
				border: 1px solid #555;
				color: #fff;
				padding: 4px;
				border-radius: 3px;
				font-family: inherit;
				font-size: 11px;
			}

			input[type="range"] {
				width: 100px;
			}

			input[type="color"] {
				width: 40px;
				height: 25px;
				padding: 0;
				cursor: pointer;
			}

			.value-display {
				color: #00ffff;
				font-weight: bold;
				min-width: 30px;
				text-align: right;
			}

			.tutorial-title {
				font-size: 18px;
				font-weight: bold;
				margin-bottom: 5px;
				color: #00ffff;
				text-shadow: 0 0 10px rgba(0, 255, 255, 0.5);
			}

			.tutorial-description {
				font-size: 13px;
				opacity: 0.9;
				color: #fff;
			}

			.type-info {
				background: rgba(0, 255, 255, 0.1);
				padding: 10px;
				margin: 10px 0;
				border-radius: 4px;
				font-size: 11px;
				border-left: 3px solid #00ffff;
				text-align: left;
			}

			.stats {
				position: absolute;
				bottom: 10px;
				left: 10px;
				background: rgba(0, 0, 0, 0.8);
				padding: 10px;
				border-radius: 4px;
				font-size: 11px;
				color: #00ff00;
				font-family: 'Courier New', monospace;
			}

			#objectList {
				max-height: 150px;
				overflow-y: auto;
				background: #111;
				border: 1px solid #333;
				border-radius: 4px;
				padding: 5px;
			}

			.object-item {
				padding: 5px;
				margin: 2px 0;
				background: #222;
				border-radius: 3px;
				cursor: pointer;
				transition: background 0.2s;
				font-size: 11px;
			}

			.object-item:hover {
				background: #333;
			}

			.object-item.selected {
				background: #004400;
				border: 1px solid #00ff00;
			}
		</style>
	</head>
	<body>
		<div id="info">
			<div class="tutorial-title">Three.js TypeScript Tutorial - 02 Typed Geometries</div>
			<div class="tutorial-description">ÂûãÂÆâÂÖ®„Å™„Ç∏„Ç™„É°„Éà„É™„Éª„Éû„ÉÜ„É™„Ç¢„É´„Éï„Ç°„ÇØ„Éà„É™„Éº„Å®„É¶„Éã„Ç™„É≥Âûã„ÅÆÊ¥ªÁî®</div>
			<div class="type-info">
				<strong>TypeScript Features:</strong> Union Types, Type Guards, Generic Constraints, Factory Pattern
				<br><strong>Advanced Types:</strong> Conditional Types, Mapped Types, Template Literal Types
			</div>
		</div>

		<div id="controls">
			<div class="control-section">
				<h3>üèóÔ∏è Object Creation</h3>
				<div class="control-row">
					<label>Geometry:</label>
					<select id="geometryType">
						<option value="box">Box</option>
						<option value="sphere">Sphere</option>
						<option value="cone">Cone</option>
						<option value="cylinder">Cylinder</option>
						<option value="torus">Torus</option>
						<option value="dodecahedron">Dodecahedron</option>
						<option value="plane">Plane</option>
					</select>
				</div>
				<div class="control-row">
					<label>Material:</label>
					<select id="materialType">
						<option value="basic">Basic</option>
						<option value="lambert">Lambert</option>
						<option value="phong">Phong</option>
						<option value="standard">Standard</option>
						<option value="normal">Normal</option>
						<option value="wireframe">Wireframe</option>
					</select>
				</div>
				<div class="control-row">
					<label>Color:</label>
					<input type="color" id="objectColor" value="#00ff88">
				</div>
				<button id="createObject">Create Object</button>
				<button id="clearAll">Clear All</button>
			</div>

			<div class="control-section">
				<h3>‚öôÔ∏è Geometry Parameters</h3>
				<div id="geometryParams">
					<!-- Dynamic geometry parameters -->
				</div>
			</div>

			<div class="control-section">
				<h3>üé® Material Properties</h3>
				<div id="materialParams">
					<!-- Dynamic material parameters -->
				</div>
			</div>

			<div class="control-section">
				<h3>üì¶ Objects</h3>
				<div id="objectList">
					<!-- Object list -->
				</div>
				<button id="removeSelected">Remove Selected</button>
			</div>
		</div>

		<div class="stats" id="stats">
			Objects: 0 | Triangles: 0 | FPS: 0
		</div>

		<script type="module">
			import * as THREE from 'three';
			import { TypedGeometryFactory, TypedObjectFactory } from '../src/typed-geometry-factory.ts';

			/**
			 * ÂûãÂÆâÂÖ®„Å™„Ç∏„Ç™„É°„Éà„É™„Ç∑„Éß„Éº„Ç±„Éº„Çπ„ÇØ„É©„Çπ
			 */
			class TypedGeometryShowcase {
				private camera: THREE.PerspectiveCamera;
				private scene: THREE.Scene;
				private renderer: THREE.WebGLRenderer;
				private objects: THREE.Mesh[] = [];
				private selectedObject: THREE.Mesh | null = null;
				private animationId: number | null = null;
				private clock = new THREE.Clock();

				constructor() {
					this.setupScene();
					this.setupLighting();
					this.setupControls();
					this.start();
				}

				private setupScene(): void {
					// „Ç´„É°„É©
					this.camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
					this.camera.position.set(5, 5, 5);
					this.camera.lookAt(0, 0, 0);

					// „Ç∑„Éº„É≥
					this.scene = new THREE.Scene();
					this.scene.background = new THREE.Color(0x000814);

					// „É¨„É≥„ÉÄ„É©„Éº
					this.renderer = new THREE.WebGLRenderer({ antialias: true });
					this.renderer.setPixelRatio(window.devicePixelRatio);
					this.renderer.setSize(window.innerWidth, window.innerHeight);
					this.renderer.shadowMap.enabled = true;
					this.renderer.shadowMap.type = THREE.PCFSoftShadowMap;
					document.body.appendChild(this.renderer.domElement);

					// „É™„Çµ„Ç§„Ç∫„Ç§„Éô„É≥„Éà
					window.addEventListener('resize', this.onWindowResize.bind(this));
				}

				private setupLighting(): void {
					// Áí∞Â¢ÉÂÖâ
					const ambientLight = new THREE.AmbientLight(0x404040, 0.4);
					this.scene.add(ambientLight);

					// ÊåáÂêëÊÄß„É©„Ç§„Éà
					const directionalLight = new THREE.DirectionalLight(0xffffff, 1);
					directionalLight.position.set(10, 10, 5);
					directionalLight.castShadow = true;
					directionalLight.shadow.mapSize.width = 2048;
					directionalLight.shadow.mapSize.height = 2048;
					this.scene.add(directionalLight);

					// „Éù„Ç§„É≥„Éà„É©„Ç§„Éà
					const pointLight = new THREE.PointLight(0x00ffff, 0.5, 50);
					pointLight.position.set(-5, 5, -5);
					this.scene.add(pointLight);
				}

				private setupControls(): void {
					const createBtn = document.getElementById('createObject') as HTMLButtonElement;
					const clearBtn = document.getElementById('clearAll') as HTMLButtonElement;
					const removeBtn = document.getElementById('removeSelected') as HTMLButtonElement;
					const geometrySelect = document.getElementById('geometryType') as HTMLSelectElement;
					const materialSelect = document.getElementById('materialType') as HTMLSelectElement;

					createBtn.addEventListener('click', () => this.createObject());
					clearBtn.addEventListener('click', () => this.clearAll());
					removeBtn.addEventListener('click', () => this.removeSelected());
					
					geometrySelect.addEventListener('change', () => this.updateGeometryParams());
					materialSelect.addEventListener('change', () => this.updateMaterialParams());

					// ÂàùÊúü„Éë„É©„É°„Éº„ÇøË®≠ÂÆö
					this.updateGeometryParams();
					this.updateMaterialParams();
				}

				private updateGeometryParams(): void {
					const geometryType = (document.getElementById('geometryType') as HTMLSelectElement).value;
					const container = document.getElementById('geometryParams') as HTMLDivElement;
					
					container.innerHTML = '';

					switch (geometryType) {
						case 'box':
							this.createRangeInput(container, 'width', 1, 0.1, 5, 0.1);
							this.createRangeInput(container, 'height', 1, 0.1, 5, 0.1);
							this.createRangeInput(container, 'depth', 1, 0.1, 5, 0.1);
							break;
						case 'sphere':
							this.createRangeInput(container, 'radius', 1, 0.1, 3, 0.1);
							this.createRangeInput(container, 'widthSegments', 32, 3, 64, 1);
							this.createRangeInput(container, 'heightSegments', 16, 2, 32, 1);
							break;
						case 'cone':
							this.createRangeInput(container, 'radius', 1, 0.1, 3, 0.1);
							this.createRangeInput(container, 'height', 2, 0.1, 5, 0.1);
							this.createRangeInput(container, 'radialSegments', 8, 3, 32, 1);
							break;
						case 'torus':
							this.createRangeInput(container, 'radius', 1, 0.1, 3, 0.1);
							this.createRangeInput(container, 'tube', 0.4, 0.1, 1, 0.1);
							this.createRangeInput(container, 'radialSegments', 8, 3, 32, 1);
							this.createRangeInput(container, 'tubularSegments', 6, 3, 32, 1);
							break;
					}
				}

				private updateMaterialParams(): void {
					const materialType = (document.getElementById('materialType') as HTMLSelectElement).value;
					const container = document.getElementById('materialParams') as HTMLDivElement;
					
					container.innerHTML = '';

					switch (materialType) {
						case 'phong':
							this.createRangeInput(container, 'shininess', 30, 0, 100, 1);
							break;
						case 'standard':
							this.createRangeInput(container, 'roughness', 1, 0, 1, 0.01);
							this.createRangeInput(container, 'metalness', 0, 0, 1, 0.01);
							break;
					}

					if (materialType !== 'normal') {
						this.createRangeInput(container, 'opacity', 1, 0, 1, 0.01);
					}
				}

				private createRangeInput(container: HTMLElement, name: string, value: number, min: number, max: number, step: number): void {
					const row = document.createElement('div');
					row.className = 'control-row';
					
					const label = document.createElement('label');
					label.textContent = name + ':';
					
					const input = document.createElement('input');
					input.type = 'range';
					input.id = `${name}Input`;
					input.min = min.toString();
					input.max = max.toString();
					input.step = step.toString();
					input.value = value.toString();
					
					const display = document.createElement('span');
					display.className = 'value-display';
					display.textContent = value.toString();
					
					input.addEventListener('input', () => {
						display.textContent = input.value;
					});
					
					row.appendChild(label);
					row.appendChild(input);
					row.appendChild(display);
					container.appendChild(row);
				}

				private createObject(): void {
					const geometryType = (document.getElementById('geometryType') as HTMLSelectElement).value;
					const materialType = (document.getElementById('materialType') as HTMLSelectElement).value;
					const color = (document.getElementById('objectColor') as HTMLInputElement).value;

					// „Ç∏„Ç™„É°„Éà„É™Ë®≠ÂÆö„ÅÆÂèéÈõÜ
					const geometryConfig = this.collectGeometryConfig(geometryType);
					const materialConfig = this.collectMaterialConfig(materialType, color);

					// ÂûãÂÆâÂÖ®„Å™„Ç™„Éñ„Ç∏„Çß„ÇØ„Éà‰ΩúÊàê
					const objectConfig = {
						geometry: { type: geometryType as any, config: geometryConfig },
						material: { type: materialType as any, config: materialConfig },
						transform: {
							position: {
								x: (Math.random() - 0.5) * 10,
								y: (Math.random() - 0.5) * 10,
								z: (Math.random() - 0.5) * 10
							}
						},
						name: `${geometryType}_${materialType}_${this.objects.length}`
					};

					const mesh = TypedObjectFactory.createMesh(objectConfig);
					mesh.castShadow = true;
					mesh.receiveShadow = true;
					
					this.scene.add(mesh);
					this.objects.push(mesh);
					this.updateObjectList();
				}

				private collectGeometryConfig(type: string): any {
					const config: any = {};
					const inputs = document.getElementById('geometryParams')?.querySelectorAll('input[type="range"]');
					
					inputs?.forEach(input => {
						const name = input.id.replace('Input', '');
						const value = parseFloat((input as HTMLInputElement).value);
						config[name] = value;
					});
					
					return config;
				}

				private collectMaterialConfig(type: string, color: string): any {
					const config: any = { color };
					const inputs = document.getElementById('materialParams')?.querySelectorAll('input[type="range"]');
					
					inputs?.forEach(input => {
						const name = input.id.replace('Input', '');
						const value = parseFloat((input as HTMLInputElement).value);
						config[name] = value;
					});
					
					return config;
				}

				private updateObjectList(): void {
					const container = document.getElementById('objectList') as HTMLDivElement;
					container.innerHTML = '';

					this.objects.forEach((obj, index) => {
						const item = document.createElement('div');
						item.className = 'object-item';
						item.textContent = `${index + 1}. ${obj.name}`;
						item.addEventListener('click', () => this.selectObject(obj, item));
						container.appendChild(item);
					});
				}

				private selectObject(obj: THREE.Mesh, element: HTMLElement): void {
					// Ââç„ÅÆÈÅ∏Êäû„ÇíËß£Èô§
					document.querySelectorAll('.object-item').forEach(el => el.classList.remove('selected'));
					
					// Êñ∞„Åó„ÅÑÈÅ∏Êäû
					this.selectedObject = obj;
					element.classList.add('selected');
				}

				private removeSelected(): void {
					if (!this.selectedObject) return;

					this.scene.remove(this.selectedObject);
					this.selectedObject.geometry.dispose();
					(this.selectedObject.material as THREE.Material).dispose();
					
					const index = this.objects.indexOf(this.selectedObject);
					if (index > -1) {
						this.objects.splice(index, 1);
					}
					
					this.selectedObject = null;
					this.updateObjectList();
				}

				private clearAll(): void {
					this.objects.forEach(obj => {
						this.scene.remove(obj);
						obj.geometry.dispose();
						(obj.material as THREE.Material).dispose();
					});
					
					this.objects = [];
					this.selectedObject = null;
					this.updateObjectList();
				}

				private onWindowResize(): void {
					this.camera.aspect = window.innerWidth / window.innerHeight;
					this.camera.updateProjectionMatrix();
					this.renderer.setSize(window.innerWidth, window.innerHeight);
				}

				private animate(): void {
					this.animationId = requestAnimationFrame(this.animate.bind(this));
					
					const time = this.clock.getElapsedTime();
					
					// „Ç™„Éñ„Ç∏„Çß„ÇØ„Éà„ÅÆ„Ç¢„Éã„É°„Éº„Ç∑„Éß„É≥
					this.objects.forEach((obj, index) => {
						obj.rotation.x = time * 0.5 + index * 0.1;
						obj.rotation.y = time * 0.3 + index * 0.15;
					});

					// Áµ±Ë®àÊÉÖÂ†±„ÅÆÊõ¥Êñ∞
					this.updateStats();
					
					this.renderer.render(this.scene, this.camera);
				}

				private updateStats(): void {
					const triangles = this.objects.reduce((sum, obj) => {
						const geometry = obj.geometry;
						return sum + (geometry.attributes.position?.count || 0) / 3;
					}, 0);

					const stats = document.getElementById('stats') as HTMLDivElement;
					stats.textContent = `Objects: ${this.objects.length} | Triangles: ${Math.floor(triangles)} | FPS: ${Math.round(1 / this.clock.getDelta())}`;
				}

				public start(): void {
					this.animate();
				}

				public dispose(): void {
					if (this.animationId) {
						cancelAnimationFrame(this.animationId);
					}
					this.clearAll();
					this.renderer.dispose();
				}
			}

			// „Ç¢„Éó„É™„Ç±„Éº„Ç∑„Éß„É≥ÈñãÂßã
			const app = new TypedGeometryShowcase();

			// TypeScriptÈñãÁô∫ËÄÖÂêë„Åë„Ç≥„É≥„ÇΩ„Éº„É´ÊÉÖÂ†±
			console.group('üîß TypeScript Three.js Development');
			console.log('üìù Type Safety:', 'Full compile-time type checking');
			console.log('üè≠ Factory Pattern:', 'Type-safe object creation');
			console.log('üîó Union Types:', 'Geometry and Material type constraints');
			console.log('üéØ Generic Types:', 'Parameterized type safety');
			console.log('‚ö° IntelliSense:', 'Full IDE support and autocomplete');
			console.groupEnd();

			// „ÇØ„É™„Éº„É≥„Ç¢„ÉÉ„Éó
			window.addEventListener('beforeunload', () => {
				app.dispose();
			});
		</script>

	</body>
</html>